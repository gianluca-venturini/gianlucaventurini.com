---
title: TODO
snippet: TODO
cover: /uploads/blog-subscribe/blog-subscribe-cover.webp
date: 2024-12-20T15:00:00.000Z
---
I always find declarative programming fascinating: we just describe the result we want and an “oracle” conjures a solution for us. A lot of smart people spent a decades packaging algorithms in solvers of various kinds and I wanted an excuse to go and play with some of these solvers to try to demystify them.

In this post I want to describe what I learned solving a toy flow optimization problem with MIP and SAT solvers. I picked the belt balancer from the Factorio video game. It looks innocuous, but it has NP-hard complexity and a lot of nuances and hidden challenges. It's possible to solve intuitively small versions, making it fun, but it quickly scales to humanly impossible even for medium instances. What the majority of players do is to use online solutions that people come up with. One of the game mechanics is sharing the designs, called blueprints, as a string and there's a thriving community built around increasingly complex and more efficient designs.

Let's define the problem next.

# The Throughput-Unlimited Factorio Belt Balancer
A core dynamic in Factorio is transporting items between different production buildings using conveyor belts, e.g., transporting raw stone from a mining drill to a Stone Furnace to be transformed into a brick. Since the throughput of a belt lane is limited, it's necessary to have multiple parallel lanes. To help prevent bottlenecks in the factory, parallel lanes needs to be balanced, for examples preventing a slow furnace from slowing down mining.

To perfectly balance two belt lanes, we can use Mixer component, that's a 2x2 Belt Balancer. The problem arises when you have more than two lanes. We want two properties: all the inputs need to be connected to all the outputs and the total maximum flow in input needs to be maintained in output. If only the former problem is solved we have a Throughput-Limited balancer, that is very easy to build, takes up less space, but unfortunately slows down all the lanes. The Throughput-Unlimited Belt Balancer instead ensures that every input flow is evenly distributed across all the outputs

Finding a feasible solution is NP-hard, because we can't do any better than start placing the components on a 2D grid and check if the properties are respected. Furthermore, finding the optimal solution (e.g. minimum number of components) is NP-complete, because will require enumerating all the possible solutions in order to find the best one. For this project, I focused on feasibility and making the balancer in a reasonably small 2D space, since the player cares about area occupied, not number of components. Additionally, it's necessary to discard certain feasible non-optimal solutions because of a subtle game mechanics I'll explain in a bit. Fortunately I found a greedy algorithm to do it and the overall complexity is NP-hard, still not great, but spending few hours it's possible to find solutions to a meaningful-sized problem, like a 16x16 balancer on a 16x16 grid.

Let's see next a simple implementation using Mixed Integer Programming.
# First implementation: Mixer Integer Programming
This first model is Mixed Integer Programming, I used the SCIP solver and Google OR-tools framework. I created a binary variable array for every cell, every component and every direction. We have three type of components: belts, underground belts and mixers. Belts take up one cell, mixers take up two cells, and underground belts take up two cells. Underground belts are set apart up to a maximum distance, modeled as an extra dimension on the array e.g. entrance 3 cells away is `u[x][y][d][3]` where x, y are the coordinates of the cell that contains the entrance, d is the direction and 3 is the distance of the exit in direction `d` from the entrance.

// TODO: add variable code

This first implementation works correctly for small grids, for example it can compute a 2x2 balancer and invert two flows (in about 1minute of computation), that are both trivial problems that can be solved by hand. The main problem of this approach is numeric instability: since the flows are modeled as floating point variables and there are a lot of "equal" constraints, on everything larger than a 2x3 grid the numeric errors accumulated and made those constraints not satisfied producing an infeasible solution or never terminating.

Since this model doesn't even scale to a 3x3 I needed to explore alternative approaches. Before migrating to a different solver I built tests and tooling to inspect the solution.
### How to test the solution
Firstly I needed to decide how to represent the output in console, for me to understand if it makes sense or something went wrong.

// TODO: belt notation

Secondly I built tests around very simple cases:
- transport a single flow on opposite side of the grid
- mix two flows with a single mixer
- use underground belts to minimize the number of components used
These tests give me confidence that every change I make doesn't cause previous solutions to break. I used the notation I invented above to have a quick visual feedback when a test fails.

It proved to be very valuable to also represent flows in every cell, in order to validate that every component is moving the flows according to the constraint I intended. Many times I modeled the constraints incorrectly and the solver cleverly exploited bugs in my model to quickly reach an incorrect solution.

Another very useful tool is testing the solution inside the game. Factorio conveniently accept a base64 representation of the components on the 2D grid, so I can easily export what I believe being the solution and validate that it's indeed correct inside the game.

Lastly a powerful debugging technique I invented to spot out broken constraints is providing a known solution and see what constraints it violates. Proving that a known solution is correct in my experience helps to find 90% of the mistakes, even the very subtle one.

With all these new fancy tools we can next migrate to CP-SAT.
# Discretize flows: CP-SAT
CP-SAT is a Satisfiability solver built at Google. It can't deal with floating variables, so I discretized the flows. This solves the numeric instability problem, but raises the new issue: needing to know how many times the input flows will be split before reaching the output. It's necessary to set the input flow to at least that number (or a multiple of it) since the solver can only deal with integers and splitting integers in two not always returns an integer.

Besides changing the flow variables type, nothing else in the model needed to be changed and worked much better out-of-the-box yielding immediately solutions up to 6x6 in very little time. The 8x8 solution was feasible after 30min of computation, suggesting an excessive number of free binary variables in the model and a very large search space.

A very useful optimization I implemented was to represent underground belts as two independent components and model the underground flow with a second flow grind, that interacts with the rest of the flow grid through underground belt components.

// Show visualization underground grid

An additional improvement I adopted was hinting to the underground flows to be zero. I don't know exactly why it works, but a plausible explanation is that zeroing underground flow implies not using underground belts, and since they are very sparse in known solutions it converges faster. After this optimization we can find a 8x8 solution in 15minutes.

Additionally, if we assume that the first and the last rows must have mixers and we add a couple of belts (breaking the symmetry) the solver finds an 8x8 solution in just 83s, great improvement!

// TODO: supply incomplete solution

As a rule of thumb: the lower the number of free binary variables the solver needs to find, the faster it will find a feasible solution. Using this heuristic I removed the `direction` as a dimension in every component vector (reducing the number of every vector by 75%) and set it as stand-alone variable. That allows us to remove few redundant variables.

// TODO: add direction as additional parameter in the conditional constraint

After spending many hours experimenting with various problem formulations, objective functions, hints, and solver strategies to find a feasible solution, I eventually hit a wall trying to and was never able to find a 16x16 balancer. Just to double-check if limited memory in my laptop was an issue I executed on a 48-core, 384 GB ram machine, with no feasible solution after few hours. With no other better idea in mind, I decided to decompose the problem in sub-problems I could solve independently, let's see how in the new section.

# Pre-computing flow between mixers with Banes Networks
Trying to model some balancer by hand I noticed a common abstract structure: two sources are mixed together, then the two resulting flows are mixed with two other flows with two mixers, than the four flows with other four etc. This suggests that I can abstract how flows are mixed and provide an abstract representation of the network and pass it to the solver in form of constraints. Modeling this problem in this way tell the solver exactly how many mixers it will need to place, as well as input and output of every mixer. Then the solver only needs to decide where to place the components. Every flow can only assume three values: -1, 0 and 1. 

In order to force the output of a mixer to go as input of the next one I made them different flows: that's a [https://en.wikipedia.org/wiki/Graph_coloring](graph coloring problem). Empirically I observed that the number of flows remains the same, although I haven't studied the properties so it may be wrong at dimensions higher than 16x16.

// TODO: representation of the network as suggestion

Doing some research I found out that these abstract flow networks with two inputs and two outputs are called Banes networks, they are a special case of [https://en.wikipedia.org/wiki/Clos_network](Clos Networks).

These networks are very easy to build by hand since they follow a regular structure, next step could be designing a greedy algorithm to build them. For now I resorted in hard-coding them as input.

This technique, combined with fixing few mixers at the beginning and at the end and symmetry breaking allowed me to find the solution of the 16x16 balancer in 1:30h. I'm pretty satisfied about the result and I think I'll stop here for the time being since finding a 32x32 is exponentially harder and will require many additional architecture innovations and model optimizations.

# A curious bug
While testing a balancer in game, I realized it was producing less than the maximum theoretical throughput on some outputs. That was due to belt not curving as a consequence of an adjacent straight belt. This condition happens only if we're merging flows from two belts to one, but this should never happen because every flow starts in a mixer and always end in a mixer.

// TODO: picture of straight belt half flow

After some debugging a realized that it's due to the solver stopping when it finds a feasible solution, without trying to remove unnecessary components and leaving extra belts around in empty spaces. The solution is very simple: add an objective function that penalizes solutions that are using more components. It's not necessary to run the solver much longer than without the objective function, since once found a feasible solution it's trivial to remove components that don't contribute to the solution.

# Conclusions
We started this journey building a linear model and having SCIP finding very simple solutions, but could not even crack a 4x4 balancer that is easy to build by hand. Migrating to CP-SAT and applying various optimizations allowed us to arrive at an 8x8 balancer that is definitely very hard to build by hand. Splitting the problems in two sub-problems: pre-compute mixer wiring with Banes Networks and then placement with CP-SAT allowed us to scale and find the exponentially harder 16x16 that I can confidently say it's impossible to find by hand.

It's been an interesting journey. I learned a lot along the way: how to model a problem for SCIP and CP-SAT. All the different type of linear and non-linear constraints. The role of the objective function.

// Table of running time